# FF Indexer GraphQL Schema
# This schema mirrors the RESTful API with the same request/response format

# Scalar types
scalar Time
scalar JSON
scalar Uint64
scalar Uint8

# Order enumeration for sorting
enum Order {
  asc
  desc
}

# TokenSortBy enumeration for token sorting
enum TokenSortBy {
  created_at
  latest_provenance
}

# Artist/Creator information
type Artist {
  did: String!
  name: String!
}

# Publisher information
type Publisher {
  name: String
  url: String
}

# Token metadata
type TokenMetadata {
  token_id: Uint64!
  origin_json: JSON
  latest_json: JSON
  latest_hash: String
  enrichment_level: String!
  last_refreshed_at: Time
  image_url: String
  animation_url: String
  name: String
  description: String
  artists: [Artist!]
  publisher: Publisher
  mime_type: String
  created_at: Time!
  updated_at: Time!
}

# Token owner (balance record)
type Owner {
  owner_address: String!
  quantity: String!
  created_at: Time!
  updated_at: Time!
}

# Provenance event
type ProvenanceEvent {
  id: Uint64!
  token_id: Uint64!
  chain: String!
  event_type: String!
  from_address: String
  to_address: String
  quantity: String
  tx_hash: String
  block_number: Uint64
  block_hash: String
  timestamp: Time!
  raw: JSON
  created_at: Time!
  updated_at: Time!
}

# Paginated owners list
type PaginatedOwners {
  items: [Owner!]!
  offset: Uint64
  total: Uint64!
}

# Paginated provenance events list
type PaginatedProvenanceEvents {
  items: [ProvenanceEvent!]!
  offset: Uint64
  total: Uint64!
}

# Paginated owner provenances list
type PaginatedOwnerProvenances {
  items: [OwnerProvenance!]!
  offset: Uint64
  total: Uint64!
}

# Owner provenance - latest provenance event per owner
type OwnerProvenance {
  owner_address: String!
  last_timestamp: Time!
  last_tx_index: Uint64!
  last_event_type: String!
  created_at: Time!
  updated_at: Time!
}

# Enrichment source data from vendor APIs
type EnrichmentSource {
  token_id: Uint64!
  vendor: String!
  vendor_json: JSON
  vendor_hash: String
  image_url: String
  animation_url: String
  name: String
  description: String
  artists: [Artist!]
  mime_type: String
  created_at: Time!
  updated_at: Time!
}

# Media asset information
type MediaAsset {
  id: Int!
  source_url: String!
  mime_type: String
  file_size_bytes: Int
  provider: String!
  provider_asset_id: String
  provider_metadata: JSON
  variant_urls: JSON!
  created_at: Time!
  updated_at: Time!
}

# Unified token display data (merges metadata and enrichment source)
type TokenDisplay {
  image_url: String
  animation_url: String
  name: String
  description: String
  publisher: Publisher
  artists: [Artist!]
  mime_type: String
}

# Token with optional expansions
type Token {
  id: Uint64!
  token_cid: String!
  chain: String!
  standard: String!
  contract_address: String!
  token_number: String!
  current_owner: String
  burned: Boolean!
  viewable: Boolean!
  last_provenance_timestamp: Time
  created_at: Time!
  updated_at: Time!
  display: TokenDisplay
  metadata: TokenMetadata
  owners: PaginatedOwners
  provenance_events: PaginatedProvenanceEvents
  owner_provenances: PaginatedOwnerProvenances
  enrichment_source: EnrichmentSource
  metadata_media_assets: [MediaAsset!] @deprecated(reason: "Use 'media_assets' instead. This field will be removed in a future version.")
  enrichment_source_media_assets: [MediaAsset!] @deprecated(reason: "Use 'media_assets' instead. This field will be removed in a future version.")
  media_assets: [MediaAsset!]
}

# Paginated tokens list
type TokenList {
  items: [Token!]!
  offset: Uint64
  total: Uint64! @deprecated(reason: "reason: Use the offset as the indicator for next page")
}

# Change journal entry
type Change {
  id: Uint64!
  subject_type: String!
  subject_id: String!
  changed_at: Time!
  meta: JSON
  subject: JSON
  created_at: Time!
  updated_at: Time!
}

# Paginated changes list
type ChangeList {
  items: [Change!]!
  offset: Uint64
  next_anchor: Uint64
  total: Uint64!
}

# Result of triggering indexing
type TriggerIndexingResult {
  workflow_id: String!
  run_id: String!
}

# Address indexing job information
type AddressIndexingJobInfo {
  address: String!
  workflow_id: String!
}

# Result of triggering address indexing (returns array of jobs)
type TriggerAddressIndexingResult {
  jobs: [AddressIndexingJobInfo!]!
}

# Workflow status information
type WorkflowStatus {
  workflow_id: String!
  run_id: String!
  status: String!
  start_time: Time
  close_time: Time
  execution_time_ms: Uint64
}

# Root Query type
type Query {
  # Get a single token by CID
  # Equivalent to: GET /api/v1/tokens/:cid
  # Note: Expansions are auto-detected from your query fields. The 'expands' parameter is optional for backward compatibility.
  token(
    cid: String!
    expands: [String!] @deprecated(reason: "Expansions are now auto-detected from your GraphQL query fields (owners, provenance_events, enrichment_source, metadata_media_assets, enrichment_source_media_assets). Explicitly specifying expands is no longer necessary.")
    owners_limit: Uint8 = 10
    owners_offset: Uint64 = 0
    provenance_events_limit: Uint8 = 10
    provenance_events_offset: Uint64 = 0
    provenance_events_order: Order = desc
  ): Token

  # List tokens with filters
  # Equivalent to: GET /api/v1/tokens
  # Note: Expansions are auto-detected from your query fields. The 'expands' parameter is optional for backward compatibility.
  # Important: When querying multiple tokens, owners and provenance_events expansions return a fixed number of items (first 20 items per token).
  # Pagination parameters (owners_limit, owners_offset, provenance_events_limit, provenance_events_offset, provenance_events_order) are NOT supported for bulk token queries.
  # Use the single token query (token) for paginated owners and provenance_events.
  tokens(
    owners: [String!]
    chains: [String!]
    contract_addresses: [String!]
    token_numbers: [String!]
    token_ids: [Uint64!]
    token_cids: [String!]
    limit: Uint8 = 20
    offset: Uint64 = 0
    include_unviewable: Boolean = false
    sort_by: TokenSortBy = latest_provenance
    sort_order: Order = desc
    expands: [String!] @deprecated(reason: "Expansions are now auto-detected from your GraphQL query fields (owners, provenance_events, enrichment_source, metadata_media_assets, enrichment_source_media_assets). Explicitly specifying expands is no longer necessary.")
    owners_limit: Uint8 = 10 @deprecated(reason: "Pagination parameters are not supported for bulk token queries. Use the single token query (token) for paginated owners.")
    owners_offset: Uint64 = 0 @deprecated(reason: "Pagination parameters are not supported for bulk token queries. Use the single token query (token) for paginated owners.")
    provenance_events_limit: Uint8 = 10 @deprecated(reason: "Pagination parameters are not supported for bulk token queries. Use the single token query (token) for paginated provenance events.")
    provenance_events_offset: Uint64 = 0 @deprecated(reason: "Pagination parameters are not supported for bulk token queries. Use the single token query (token) for paginated provenance events.")
    provenance_events_order: Order = desc @deprecated(reason: "Pagination parameters are not supported for bulk token queries. Use the single token query (token) for paginated provenance events.")
  ): TokenList

  # Get changes with filters
  # Equivalent to: GET /api/v1/changes
  # Returns changes in ascending order by ID (sequential audit log)
  # Recommended: Use 'anchor' with 'next_anchor' from previous response for cursor-based pagination
  # Deprecated parameters: 'since', 'offset', 'order' - use 'anchor' instead
  # Note: The 'subject' field expansion is auto-detected from your query. The 'expand' parameter is optional for backward compatibility.
  changes(
    token_ids: [Uint64!]
    token_cids: [String!]
    addresses: [String!]
    subject_types: [String!]
    subject_ids: [String!]
    anchor: Uint64
    since: String @deprecated(reason: "Use 'anchor' for reliable ID-based pagination. Different subject types use different timestamp semantics.")
    limit: Uint8 = 20
    offset: Uint64 = 0 @deprecated(reason: "Use 'anchor' for cursor-based pagination instead. Offset only applies with 'since' parameter.")
    order: Order = asc @deprecated(reason: "Order parameter only applies when using deprecated 'since' parameter. Always ascending with 'anchor'.")
    expand: [String!] @deprecated(reason: "Expansion is now auto-detected from your GraphQL query fields (subject). Explicitly specifying expand is no longer necessary.")
  ): ChangeList

  # Get workflow status by workflow ID and run ID
  # Equivalent to: GET /api/v1/workflows/:workflow_id/runs/:run_id
  workflowStatus(
    workflow_id: String!
    run_id: String!
  ): WorkflowStatus

  # Get indexing job by workflow ID
  # Equivalent to: GET /api/v1/indexing/jobs/:workflow_id
  indexingJob(
    workflow_id: String!
  ): IndexingJob
}

# Root Mutation type
type Mutation {
  # Trigger indexing for tokens by CIDs (open, no authentication required)
  # Equivalent to: POST /api/v1/tokens/index
  triggerTokenIndexing(
    token_cids: [String!]!
  ): TriggerIndexingResult

  # Trigger indexing for tokens by owner addresses (requires authentication)
  # Equivalent to: POST /api/v1/tokens/owners/index
  # Returns a single workflow ID for tracking (backward compatible)
  # Deprecated: Use triggerAddressIndexing instead
  triggerOwnerIndexing(
    addresses: [String!]!
  ): TriggerIndexingResult

  # Trigger indexing for tokens by owner addresses with job tracking (requires authentication)
  # Equivalent to: POST /api/v1/tokens/addresses/index
  # Returns an array of jobs with workflow IDs for tracking each address's indexing progress
  triggerAddressIndexing(
    addresses: [String!]!
  ): TriggerAddressIndexingResult

  # Trigger metadata refresh for tokens by IDs or CIDs (open, no authentication required)
  # Equivalent to: POST /api/v1/tokens/metadata/index
  # At least one of token_ids or token_cids must be provided
  triggerMetadataIndexing(
    token_ids: [Uint64!]
    token_cids: [String!]
  ): TriggerIndexingResult

  # Create a new webhook client (requires API key authentication only, JWT not accepted)
  # Equivalent to: POST /api/v1/webhooks/clients
  createWebhookClient(
    webhook_url: String!
    event_filters: [String!]!
    retry_max_attempts: Int
  ): WebhookClientResult
}

# Webhook client result
type WebhookClientResult {
  client_id: String!
  webhook_url: String!
  webhook_secret: String!
  event_filters: [String!]!
  is_active: Boolean!
  retry_max_attempts: Int!
  created_at: Time!
  updated_at: Time!
}

# Address indexing job
type IndexingJob {
  workflow_id: String!
  address: String!
  chain: String!
  status: String!
  tokens_processed: Int!
  total_tokens_indexed: Int
  total_tokens_viewable: Int
  current_min_block: Uint64
  current_max_block: Uint64
  started_at: Time!
  paused_at: Time
  completed_at: Time
  failed_at: Time
  canceled_at: Time
}
