// Code generated by MockGen. DO NOT EDIT.
// Source: temporal.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	adapter "github.com/feral-file/ff-indexer-v2/internal/adapter"
)

// MockWorkflowClient is a mock of WorkflowClient interface.
type MockWorkflowClient struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowClientMockRecorder
}

// MockWorkflowClientMockRecorder is the mock recorder for MockWorkflowClient.
type MockWorkflowClientMockRecorder struct {
	mock *MockWorkflowClient
}

// NewMockWorkflowClient creates a new mock instance.
func NewMockWorkflowClient(ctrl *gomock.Controller) *MockWorkflowClient {
	mock := &MockWorkflowClient{ctrl: ctrl}
	mock.recorder = &MockWorkflowClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowClient) EXPECT() *MockWorkflowClientMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockWorkflowClient) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockWorkflowClientMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockWorkflowClient)(nil).Close))
}

// ExecuteWorkflow mocks base method.
func (m *MockWorkflowClient) ExecuteWorkflow(ctx context.Context, options adapter.WorkflowOptions, workflow interface{}, args ...interface{}) (adapter.WorkflowRun, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, options, workflow}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteWorkflow", varargs...)
	ret0, _ := ret[0].(adapter.WorkflowRun)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteWorkflow indicates an expected call of ExecuteWorkflow.
func (mr *MockWorkflowClientMockRecorder) ExecuteWorkflow(ctx, options, workflow interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, options, workflow}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteWorkflow", reflect.TypeOf((*MockWorkflowClient)(nil).ExecuteWorkflow), varargs...)
}

// SignalWithStartWorkflow mocks base method.
func (m *MockWorkflowClient) SignalWithStartWorkflow(ctx context.Context, workflowID, signalName string, signalArg interface{}, options adapter.WorkflowOptions, workflow interface{}, args ...interface{}) (adapter.WorkflowRun, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, workflowID, signalName, signalArg, options, workflow}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignalWithStartWorkflow", varargs...)
	ret0, _ := ret[0].(adapter.WorkflowRun)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignalWithStartWorkflow indicates an expected call of SignalWithStartWorkflow.
func (mr *MockWorkflowClientMockRecorder) SignalWithStartWorkflow(ctx, workflowID, signalName, signalArg, options, workflow interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, workflowID, signalName, signalArg, options, workflow}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignalWithStartWorkflow", reflect.TypeOf((*MockWorkflowClient)(nil).SignalWithStartWorkflow), varargs...)
}

// MockWorkflowRun is a mock of WorkflowRun interface.
type MockWorkflowRun struct {
	ctrl     *gomock.Controller
	recorder *MockWorkflowRunMockRecorder
}

// MockWorkflowRunMockRecorder is the mock recorder for MockWorkflowRun.
type MockWorkflowRunMockRecorder struct {
	mock *MockWorkflowRun
}

// NewMockWorkflowRun creates a new mock instance.
func NewMockWorkflowRun(ctrl *gomock.Controller) *MockWorkflowRun {
	mock := &MockWorkflowRun{ctrl: ctrl}
	mock.recorder = &MockWorkflowRunMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWorkflowRun) EXPECT() *MockWorkflowRunMockRecorder {
	return m.recorder
}

// GetID mocks base method.
func (m *MockWorkflowRun) GetID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetID")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetID indicates an expected call of GetID.
func (mr *MockWorkflowRunMockRecorder) GetID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetID", reflect.TypeOf((*MockWorkflowRun)(nil).GetID))
}

// GetRunID mocks base method.
func (m *MockWorkflowRun) GetRunID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRunID")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetRunID indicates an expected call of GetRunID.
func (mr *MockWorkflowRunMockRecorder) GetRunID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRunID", reflect.TypeOf((*MockWorkflowRun)(nil).GetRunID))
}

// MockTemporalWorkflow is a mock of TemporalWorkflow interface.
type MockTemporalWorkflow struct {
	ctrl     *gomock.Controller
	recorder *MockTemporalWorkflowMockRecorder
}

// MockTemporalWorkflowMockRecorder is the mock recorder for MockTemporalWorkflow.
type MockTemporalWorkflowMockRecorder struct {
	mock *MockTemporalWorkflow
}

// NewMockTemporalWorkflow creates a new mock instance.
func NewMockTemporalWorkflow(ctrl *gomock.Controller) *MockTemporalWorkflow {
	mock := &MockTemporalWorkflow{ctrl: ctrl}
	mock.recorder = &MockTemporalWorkflowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTemporalWorkflow) EXPECT() *MockTemporalWorkflowMockRecorder {
	return m.recorder
}

// Connect mocks base method.
func (m *MockTemporalWorkflow) Connect(hostPort, namespace string) (adapter.WorkflowClient, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Connect", hostPort, namespace)
	ret0, _ := ret[0].(adapter.WorkflowClient)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Connect indicates an expected call of Connect.
func (mr *MockTemporalWorkflowMockRecorder) Connect(hostPort, namespace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockTemporalWorkflow)(nil).Connect), hostPort, namespace)
}
