// Code generated by MockGen. DO NOT EDIT.
// Source: executor.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	domain "github.com/feral-file/ff-indexer-v2/internal/domain"
	metadata "github.com/feral-file/ff-indexer-v2/internal/metadata"
	workflows "github.com/feral-file/ff-indexer-v2/internal/workflows"
)

// MockCoreExecutor is a mock of Executor interface.
type MockCoreExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockCoreExecutorMockRecorder
}

// MockCoreExecutorMockRecorder is the mock recorder for MockCoreExecutor.
type MockCoreExecutorMockRecorder struct {
	mock *MockCoreExecutor
}

// NewMockCoreExecutor creates a new mock instance.
func NewMockCoreExecutor(ctrl *gomock.Controller) *MockCoreExecutor {
	mock := &MockCoreExecutor{ctrl: ctrl}
	mock.recorder = &MockCoreExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCoreExecutor) EXPECT() *MockCoreExecutorMockRecorder {
	return m.recorder
}

// CheckTokenExists mocks base method.
func (m *MockCoreExecutor) CheckTokenExists(ctx context.Context, tokenCID domain.TokenCID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckTokenExists", ctx, tokenCID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckTokenExists indicates an expected call of CheckTokenExists.
func (mr *MockCoreExecutorMockRecorder) CheckTokenExists(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckTokenExists", reflect.TypeOf((*MockCoreExecutor)(nil).CheckTokenExists), ctx, tokenCID)
}

// CreateMetadataUpdate mocks base method.
func (m *MockCoreExecutor) CreateMetadataUpdate(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateMetadataUpdate", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateMetadataUpdate indicates an expected call of CreateMetadataUpdate.
func (mr *MockCoreExecutorMockRecorder) CreateMetadataUpdate(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMetadataUpdate", reflect.TypeOf((*MockCoreExecutor)(nil).CreateMetadataUpdate), ctx, event)
}

// CreateTokenMint mocks base method.
func (m *MockCoreExecutor) CreateTokenMint(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTokenMint", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTokenMint indicates an expected call of CreateTokenMint.
func (mr *MockCoreExecutorMockRecorder) CreateTokenMint(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTokenMint", reflect.TypeOf((*MockCoreExecutor)(nil).CreateTokenMint), ctx, event)
}

// EnhanceTokenMetadata mocks base method.
func (m *MockCoreExecutor) EnhanceTokenMetadata(ctx context.Context, tokenCID domain.TokenCID, normalizedMetadata *metadata.NormalizedMetadata) (*metadata.EnhancedMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnhanceTokenMetadata", ctx, tokenCID, normalizedMetadata)
	ret0, _ := ret[0].(*metadata.EnhancedMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EnhanceTokenMetadata indicates an expected call of EnhanceTokenMetadata.
func (mr *MockCoreExecutorMockRecorder) EnhanceTokenMetadata(ctx, tokenCID, normalizedMetadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnhanceTokenMetadata", reflect.TypeOf((*MockCoreExecutor)(nil).EnhanceTokenMetadata), ctx, tokenCID, normalizedMetadata)
}

// EnsureWatchedAddressExists mocks base method.
func (m *MockCoreExecutor) EnsureWatchedAddressExists(ctx context.Context, address string, chain domain.Chain) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureWatchedAddressExists", ctx, address, chain)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureWatchedAddressExists indicates an expected call of EnsureWatchedAddressExists.
func (mr *MockCoreExecutorMockRecorder) EnsureWatchedAddressExists(ctx, address, chain interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureWatchedAddressExists", reflect.TypeOf((*MockCoreExecutor)(nil).EnsureWatchedAddressExists), ctx, address, chain)
}

// FetchTokenMetadata mocks base method.
func (m *MockCoreExecutor) FetchTokenMetadata(ctx context.Context, tokenCID domain.TokenCID) (*metadata.NormalizedMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchTokenMetadata", ctx, tokenCID)
	ret0, _ := ret[0].(*metadata.NormalizedMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchTokenMetadata indicates an expected call of FetchTokenMetadata.
func (mr *MockCoreExecutorMockRecorder) FetchTokenMetadata(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchTokenMetadata", reflect.TypeOf((*MockCoreExecutor)(nil).FetchTokenMetadata), ctx, tokenCID)
}

// GetEthereumTokenCIDsByOwnerWithinBlockRange mocks base method.
func (m *MockCoreExecutor) GetEthereumTokenCIDsByOwnerWithinBlockRange(ctx context.Context, address string, fromBlock, toBlock uint64) ([]domain.TokenWithBlock, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEthereumTokenCIDsByOwnerWithinBlockRange", ctx, address, fromBlock, toBlock)
	ret0, _ := ret[0].([]domain.TokenWithBlock)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEthereumTokenCIDsByOwnerWithinBlockRange indicates an expected call of GetEthereumTokenCIDsByOwnerWithinBlockRange.
func (mr *MockCoreExecutorMockRecorder) GetEthereumTokenCIDsByOwnerWithinBlockRange(ctx, address, fromBlock, toBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEthereumTokenCIDsByOwnerWithinBlockRange", reflect.TypeOf((*MockCoreExecutor)(nil).GetEthereumTokenCIDsByOwnerWithinBlockRange), ctx, address, fromBlock, toBlock)
}

// GetIndexingBlockRangeForAddress mocks base method.
func (m *MockCoreExecutor) GetIndexingBlockRangeForAddress(ctx context.Context, address string, chainID domain.Chain) (*workflows.BlockRangeResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetIndexingBlockRangeForAddress", ctx, address, chainID)
	ret0, _ := ret[0].(*workflows.BlockRangeResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetIndexingBlockRangeForAddress indicates an expected call of GetIndexingBlockRangeForAddress.
func (mr *MockCoreExecutorMockRecorder) GetIndexingBlockRangeForAddress(ctx, address, chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIndexingBlockRangeForAddress", reflect.TypeOf((*MockCoreExecutor)(nil).GetIndexingBlockRangeForAddress), ctx, address, chainID)
}

// GetLatestEthereumBlock mocks base method.
func (m *MockCoreExecutor) GetLatestEthereumBlock(ctx context.Context) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestEthereumBlock", ctx)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestEthereumBlock indicates an expected call of GetLatestEthereumBlock.
func (mr *MockCoreExecutorMockRecorder) GetLatestEthereumBlock(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestEthereumBlock", reflect.TypeOf((*MockCoreExecutor)(nil).GetLatestEthereumBlock), ctx)
}

// GetLatestTezosBlock mocks base method.
func (m *MockCoreExecutor) GetLatestTezosBlock(ctx context.Context) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestTezosBlock", ctx)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestTezosBlock indicates an expected call of GetLatestTezosBlock.
func (mr *MockCoreExecutorMockRecorder) GetLatestTezosBlock(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestTezosBlock", reflect.TypeOf((*MockCoreExecutor)(nil).GetLatestTezosBlock), ctx)
}

// GetTezosTokenCIDsByAccountWithinBlockRange mocks base method.
func (m *MockCoreExecutor) GetTezosTokenCIDsByAccountWithinBlockRange(ctx context.Context, address string, fromBlock, toBlock uint64) ([]domain.TokenWithBlock, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTezosTokenCIDsByAccountWithinBlockRange", ctx, address, fromBlock, toBlock)
	ret0, _ := ret[0].([]domain.TokenWithBlock)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTezosTokenCIDsByAccountWithinBlockRange indicates an expected call of GetTezosTokenCIDsByAccountWithinBlockRange.
func (mr *MockCoreExecutorMockRecorder) GetTezosTokenCIDsByAccountWithinBlockRange(ctx, address, fromBlock, toBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTezosTokenCIDsByAccountWithinBlockRange", reflect.TypeOf((*MockCoreExecutor)(nil).GetTezosTokenCIDsByAccountWithinBlockRange), ctx, address, fromBlock, toBlock)
}

// IndexTokenWithFullProvenancesByTokenCID mocks base method.
func (m *MockCoreExecutor) IndexTokenWithFullProvenancesByTokenCID(ctx context.Context, tokenCID domain.TokenCID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexTokenWithFullProvenancesByTokenCID", ctx, tokenCID)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexTokenWithFullProvenancesByTokenCID indicates an expected call of IndexTokenWithFullProvenancesByTokenCID.
func (mr *MockCoreExecutorMockRecorder) IndexTokenWithFullProvenancesByTokenCID(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexTokenWithFullProvenancesByTokenCID", reflect.TypeOf((*MockCoreExecutor)(nil).IndexTokenWithFullProvenancesByTokenCID), ctx, tokenCID)
}

// IndexTokenWithMinimalProvenancesByBlockchainEvent mocks base method.
func (m *MockCoreExecutor) IndexTokenWithMinimalProvenancesByBlockchainEvent(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexTokenWithMinimalProvenancesByBlockchainEvent", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexTokenWithMinimalProvenancesByBlockchainEvent indicates an expected call of IndexTokenWithMinimalProvenancesByBlockchainEvent.
func (mr *MockCoreExecutorMockRecorder) IndexTokenWithMinimalProvenancesByBlockchainEvent(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexTokenWithMinimalProvenancesByBlockchainEvent", reflect.TypeOf((*MockCoreExecutor)(nil).IndexTokenWithMinimalProvenancesByBlockchainEvent), ctx, event)
}

// IndexTokenWithMinimalProvenancesByTokenCID mocks base method.
func (m *MockCoreExecutor) IndexTokenWithMinimalProvenancesByTokenCID(ctx context.Context, tokenCID domain.TokenCID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexTokenWithMinimalProvenancesByTokenCID", ctx, tokenCID)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexTokenWithMinimalProvenancesByTokenCID indicates an expected call of IndexTokenWithMinimalProvenancesByTokenCID.
func (mr *MockCoreExecutorMockRecorder) IndexTokenWithMinimalProvenancesByTokenCID(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexTokenWithMinimalProvenancesByTokenCID", reflect.TypeOf((*MockCoreExecutor)(nil).IndexTokenWithMinimalProvenancesByTokenCID), ctx, tokenCID)
}

// UpdateIndexingBlockRangeForAddress mocks base method.
func (m *MockCoreExecutor) UpdateIndexingBlockRangeForAddress(ctx context.Context, address string, chainID domain.Chain, minBlock, maxBlock uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateIndexingBlockRangeForAddress", ctx, address, chainID, minBlock, maxBlock)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateIndexingBlockRangeForAddress indicates an expected call of UpdateIndexingBlockRangeForAddress.
func (mr *MockCoreExecutorMockRecorder) UpdateIndexingBlockRangeForAddress(ctx, address, chainID, minBlock, maxBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateIndexingBlockRangeForAddress", reflect.TypeOf((*MockCoreExecutor)(nil).UpdateIndexingBlockRangeForAddress), ctx, address, chainID, minBlock, maxBlock)
}

// UpdateTokenBurn mocks base method.
func (m *MockCoreExecutor) UpdateTokenBurn(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTokenBurn", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTokenBurn indicates an expected call of UpdateTokenBurn.
func (mr *MockCoreExecutorMockRecorder) UpdateTokenBurn(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTokenBurn", reflect.TypeOf((*MockCoreExecutor)(nil).UpdateTokenBurn), ctx, event)
}

// UpdateTokenTransfer mocks base method.
func (m *MockCoreExecutor) UpdateTokenTransfer(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTokenTransfer", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTokenTransfer indicates an expected call of UpdateTokenTransfer.
func (mr *MockCoreExecutorMockRecorder) UpdateTokenTransfer(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTokenTransfer", reflect.TypeOf((*MockCoreExecutor)(nil).UpdateTokenTransfer), ctx, event)
}

// UpsertTokenMetadata mocks base method.
func (m *MockCoreExecutor) UpsertTokenMetadata(ctx context.Context, tokenCID domain.TokenCID, normalizedMetadata *metadata.NormalizedMetadata) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTokenMetadata", ctx, tokenCID, normalizedMetadata)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertTokenMetadata indicates an expected call of UpsertTokenMetadata.
func (mr *MockCoreExecutorMockRecorder) UpsertTokenMetadata(ctx, tokenCID, normalizedMetadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTokenMetadata", reflect.TypeOf((*MockCoreExecutor)(nil).UpsertTokenMetadata), ctx, tokenCID, normalizedMetadata)
}
