// Code generated by MockGen. DO NOT EDIT.
// Source: activities.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	domain "github.com/feral-file/ff-indexer-v2/internal/domain"
	metadata "github.com/feral-file/ff-indexer-v2/internal/metadata"
	workflows "github.com/feral-file/ff-indexer-v2/internal/workflows"
)

// MockExecutor is a mock of Executor interface.
type MockExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockExecutorMockRecorder
}

// MockExecutorMockRecorder is the mock recorder for MockExecutor.
type MockExecutorMockRecorder struct {
	mock *MockExecutor
}

// NewMockExecutor creates a new mock instance.
func NewMockExecutor(ctrl *gomock.Controller) *MockExecutor {
	mock := &MockExecutor{ctrl: ctrl}
	mock.recorder = &MockExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutor) EXPECT() *MockExecutorMockRecorder {
	return m.recorder
}

// CheckTokenExists mocks base method.
func (m *MockExecutor) CheckTokenExists(ctx context.Context, tokenCID domain.TokenCID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckTokenExists", ctx, tokenCID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckTokenExists indicates an expected call of CheckTokenExists.
func (mr *MockExecutorMockRecorder) CheckTokenExists(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckTokenExists", reflect.TypeOf((*MockExecutor)(nil).CheckTokenExists), ctx, tokenCID)
}

// CreateMetadataUpdate mocks base method.
func (m *MockExecutor) CreateMetadataUpdate(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateMetadataUpdate", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateMetadataUpdate indicates an expected call of CreateMetadataUpdate.
func (mr *MockExecutorMockRecorder) CreateMetadataUpdate(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateMetadataUpdate", reflect.TypeOf((*MockExecutor)(nil).CreateMetadataUpdate), ctx, event)
}

// CreateTokenMint mocks base method.
func (m *MockExecutor) CreateTokenMint(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTokenMint", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTokenMint indicates an expected call of CreateTokenMint.
func (mr *MockExecutorMockRecorder) CreateTokenMint(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTokenMint", reflect.TypeOf((*MockExecutor)(nil).CreateTokenMint), ctx, event)
}

// EnhanceTokenMetadata mocks base method.
func (m *MockExecutor) EnhanceTokenMetadata(ctx context.Context, tokenCID domain.TokenCID, normalizedMetadata *metadata.NormalizedMetadata) (*metadata.EnhancedMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnhanceTokenMetadata", ctx, tokenCID, normalizedMetadata)
	ret0, _ := ret[0].(*metadata.EnhancedMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EnhanceTokenMetadata indicates an expected call of EnhanceTokenMetadata.
func (mr *MockExecutorMockRecorder) EnhanceTokenMetadata(ctx, tokenCID, normalizedMetadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnhanceTokenMetadata", reflect.TypeOf((*MockExecutor)(nil).EnhanceTokenMetadata), ctx, tokenCID, normalizedMetadata)
}

// EnsureWatchedAddressExists mocks base method.
func (m *MockExecutor) EnsureWatchedAddressExists(ctx context.Context, address string, chain domain.Chain) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureWatchedAddressExists", ctx, address, chain)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureWatchedAddressExists indicates an expected call of EnsureWatchedAddressExists.
func (mr *MockExecutorMockRecorder) EnsureWatchedAddressExists(ctx, address, chain interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureWatchedAddressExists", reflect.TypeOf((*MockExecutor)(nil).EnsureWatchedAddressExists), ctx, address, chain)
}

// FetchTokenMetadata mocks base method.
func (m *MockExecutor) FetchTokenMetadata(ctx context.Context, tokenCID domain.TokenCID) (*metadata.NormalizedMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchTokenMetadata", ctx, tokenCID)
	ret0, _ := ret[0].(*metadata.NormalizedMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchTokenMetadata indicates an expected call of FetchTokenMetadata.
func (mr *MockExecutorMockRecorder) FetchTokenMetadata(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchTokenMetadata", reflect.TypeOf((*MockExecutor)(nil).FetchTokenMetadata), ctx, tokenCID)
}

// GetEthereumTokenCIDsByOwnerWithinBlockRange mocks base method.
func (m *MockExecutor) GetEthereumTokenCIDsByOwnerWithinBlockRange(ctx context.Context, address string, fromBlock, toBlock uint64) ([]domain.TokenWithBlock, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEthereumTokenCIDsByOwnerWithinBlockRange", ctx, address, fromBlock, toBlock)
	ret0, _ := ret[0].([]domain.TokenWithBlock)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEthereumTokenCIDsByOwnerWithinBlockRange indicates an expected call of GetEthereumTokenCIDsByOwnerWithinBlockRange.
func (mr *MockExecutorMockRecorder) GetEthereumTokenCIDsByOwnerWithinBlockRange(ctx, address, fromBlock, toBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEthereumTokenCIDsByOwnerWithinBlockRange", reflect.TypeOf((*MockExecutor)(nil).GetEthereumTokenCIDsByOwnerWithinBlockRange), ctx, address, fromBlock, toBlock)
}

// GetIndexingBlockRangeForAddress mocks base method.
func (m *MockExecutor) GetIndexingBlockRangeForAddress(ctx context.Context, address string, chainID domain.Chain) (*workflows.BlockRangeResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetIndexingBlockRangeForAddress", ctx, address, chainID)
	ret0, _ := ret[0].(*workflows.BlockRangeResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetIndexingBlockRangeForAddress indicates an expected call of GetIndexingBlockRangeForAddress.
func (mr *MockExecutorMockRecorder) GetIndexingBlockRangeForAddress(ctx, address, chainID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIndexingBlockRangeForAddress", reflect.TypeOf((*MockExecutor)(nil).GetIndexingBlockRangeForAddress), ctx, address, chainID)
}

// GetLatestEthereumBlock mocks base method.
func (m *MockExecutor) GetLatestEthereumBlock(ctx context.Context) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestEthereumBlock", ctx)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestEthereumBlock indicates an expected call of GetLatestEthereumBlock.
func (mr *MockExecutorMockRecorder) GetLatestEthereumBlock(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestEthereumBlock", reflect.TypeOf((*MockExecutor)(nil).GetLatestEthereumBlock), ctx)
}

// GetLatestTezosBlock mocks base method.
func (m *MockExecutor) GetLatestTezosBlock(ctx context.Context) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLatestTezosBlock", ctx)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLatestTezosBlock indicates an expected call of GetLatestTezosBlock.
func (mr *MockExecutorMockRecorder) GetLatestTezosBlock(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLatestTezosBlock", reflect.TypeOf((*MockExecutor)(nil).GetLatestTezosBlock), ctx)
}

// GetTezosTokenCIDsByAccountWithinBlockRange mocks base method.
func (m *MockExecutor) GetTezosTokenCIDsByAccountWithinBlockRange(ctx context.Context, address string, fromBlock, toBlock uint64) ([]domain.TokenWithBlock, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTezosTokenCIDsByAccountWithinBlockRange", ctx, address, fromBlock, toBlock)
	ret0, _ := ret[0].([]domain.TokenWithBlock)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTezosTokenCIDsByAccountWithinBlockRange indicates an expected call of GetTezosTokenCIDsByAccountWithinBlockRange.
func (mr *MockExecutorMockRecorder) GetTezosTokenCIDsByAccountWithinBlockRange(ctx, address, fromBlock, toBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTezosTokenCIDsByAccountWithinBlockRange", reflect.TypeOf((*MockExecutor)(nil).GetTezosTokenCIDsByAccountWithinBlockRange), ctx, address, fromBlock, toBlock)
}

// IndexMediaFile mocks base method.
func (m *MockExecutor) IndexMediaFile(ctx context.Context, url string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexMediaFile", ctx, url)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexMediaFile indicates an expected call of IndexMediaFile.
func (mr *MockExecutorMockRecorder) IndexMediaFile(ctx, url interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexMediaFile", reflect.TypeOf((*MockExecutor)(nil).IndexMediaFile), ctx, url)
}

// IndexTokenWithFullProvenancesByTokenCID mocks base method.
func (m *MockExecutor) IndexTokenWithFullProvenancesByTokenCID(ctx context.Context, tokenCID domain.TokenCID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexTokenWithFullProvenancesByTokenCID", ctx, tokenCID)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexTokenWithFullProvenancesByTokenCID indicates an expected call of IndexTokenWithFullProvenancesByTokenCID.
func (mr *MockExecutorMockRecorder) IndexTokenWithFullProvenancesByTokenCID(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexTokenWithFullProvenancesByTokenCID", reflect.TypeOf((*MockExecutor)(nil).IndexTokenWithFullProvenancesByTokenCID), ctx, tokenCID)
}

// IndexTokenWithMinimalProvenancesByBlockchainEvent mocks base method.
func (m *MockExecutor) IndexTokenWithMinimalProvenancesByBlockchainEvent(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexTokenWithMinimalProvenancesByBlockchainEvent", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexTokenWithMinimalProvenancesByBlockchainEvent indicates an expected call of IndexTokenWithMinimalProvenancesByBlockchainEvent.
func (mr *MockExecutorMockRecorder) IndexTokenWithMinimalProvenancesByBlockchainEvent(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexTokenWithMinimalProvenancesByBlockchainEvent", reflect.TypeOf((*MockExecutor)(nil).IndexTokenWithMinimalProvenancesByBlockchainEvent), ctx, event)
}

// IndexTokenWithMinimalProvenancesByTokenCID mocks base method.
func (m *MockExecutor) IndexTokenWithMinimalProvenancesByTokenCID(ctx context.Context, tokenCID domain.TokenCID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IndexTokenWithMinimalProvenancesByTokenCID", ctx, tokenCID)
	ret0, _ := ret[0].(error)
	return ret0
}

// IndexTokenWithMinimalProvenancesByTokenCID indicates an expected call of IndexTokenWithMinimalProvenancesByTokenCID.
func (mr *MockExecutorMockRecorder) IndexTokenWithMinimalProvenancesByTokenCID(ctx, tokenCID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IndexTokenWithMinimalProvenancesByTokenCID", reflect.TypeOf((*MockExecutor)(nil).IndexTokenWithMinimalProvenancesByTokenCID), ctx, tokenCID)
}

// UpdateIndexingBlockRangeForAddress mocks base method.
func (m *MockExecutor) UpdateIndexingBlockRangeForAddress(ctx context.Context, address string, chainID domain.Chain, minBlock, maxBlock uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateIndexingBlockRangeForAddress", ctx, address, chainID, minBlock, maxBlock)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateIndexingBlockRangeForAddress indicates an expected call of UpdateIndexingBlockRangeForAddress.
func (mr *MockExecutorMockRecorder) UpdateIndexingBlockRangeForAddress(ctx, address, chainID, minBlock, maxBlock interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateIndexingBlockRangeForAddress", reflect.TypeOf((*MockExecutor)(nil).UpdateIndexingBlockRangeForAddress), ctx, address, chainID, minBlock, maxBlock)
}

// UpdateTokenBurn mocks base method.
func (m *MockExecutor) UpdateTokenBurn(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTokenBurn", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTokenBurn indicates an expected call of UpdateTokenBurn.
func (mr *MockExecutorMockRecorder) UpdateTokenBurn(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTokenBurn", reflect.TypeOf((*MockExecutor)(nil).UpdateTokenBurn), ctx, event)
}

// UpdateTokenTransfer mocks base method.
func (m *MockExecutor) UpdateTokenTransfer(ctx context.Context, event *domain.BlockchainEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTokenTransfer", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTokenTransfer indicates an expected call of UpdateTokenTransfer.
func (mr *MockExecutorMockRecorder) UpdateTokenTransfer(ctx, event interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTokenTransfer", reflect.TypeOf((*MockExecutor)(nil).UpdateTokenTransfer), ctx, event)
}

// UpsertTokenMetadata mocks base method.
func (m *MockExecutor) UpsertTokenMetadata(ctx context.Context, tokenCID domain.TokenCID, normalizedMetadata *metadata.NormalizedMetadata) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpsertTokenMetadata", ctx, tokenCID, normalizedMetadata)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertTokenMetadata indicates an expected call of UpsertTokenMetadata.
func (mr *MockExecutorMockRecorder) UpsertTokenMetadata(ctx, tokenCID, normalizedMetadata interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertTokenMetadata", reflect.TypeOf((*MockExecutor)(nil).UpsertTokenMetadata), ctx, tokenCID, normalizedMetadata)
}
