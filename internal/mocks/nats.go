// Code generated by MockGen. DO NOT EDIT.
// Source: nats.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	nats "github.com/nats-io/nats.go"
	jetstream "github.com/nats-io/nats.go/jetstream"

	adapter "github.com/feral-file/ff-indexer-v2/internal/adapter"
)

// MockNatsConn is a mock of NatsConn interface.
type MockNatsConn struct {
	ctrl     *gomock.Controller
	recorder *MockNatsConnMockRecorder
}

// MockNatsConnMockRecorder is the mock recorder for MockNatsConn.
type MockNatsConnMockRecorder struct {
	mock *MockNatsConn
}

// NewMockNatsConn creates a new mock instance.
func NewMockNatsConn(ctrl *gomock.Controller) *MockNatsConn {
	mock := &MockNatsConn{ctrl: ctrl}
	mock.recorder = &MockNatsConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNatsConn) EXPECT() *MockNatsConnMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockNatsConn) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockNatsConnMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockNatsConn)(nil).Close))
}

// ConnectedUrl mocks base method.
func (m *MockNatsConn) ConnectedUrl() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConnectedUrl")
	ret0, _ := ret[0].(string)
	return ret0
}

// ConnectedUrl indicates an expected call of ConnectedUrl.
func (mr *MockNatsConnMockRecorder) ConnectedUrl() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConnectedUrl", reflect.TypeOf((*MockNatsConn)(nil).ConnectedUrl))
}

// LastError mocks base method.
func (m *MockNatsConn) LastError() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastError")
	ret0, _ := ret[0].(error)
	return ret0
}

// LastError indicates an expected call of LastError.
func (mr *MockNatsConnMockRecorder) LastError() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastError", reflect.TypeOf((*MockNatsConn)(nil).LastError))
}

// MockJetStream is a mock of JetStream interface.
type MockJetStream struct {
	ctrl     *gomock.Controller
	recorder *MockJetStreamMockRecorder
}

// MockJetStreamMockRecorder is the mock recorder for MockJetStream.
type MockJetStreamMockRecorder struct {
	mock *MockJetStream
}

// NewMockJetStream creates a new mock instance.
func NewMockJetStream(ctrl *gomock.Controller) *MockJetStream {
	mock := &MockJetStream{ctrl: ctrl}
	mock.recorder = &MockJetStreamMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJetStream) EXPECT() *MockJetStreamMockRecorder {
	return m.recorder
}

// Consumer mocks base method.
func (m *MockJetStream) Consumer(ctx context.Context, stream, consumer string) (adapter.Consumer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consumer", ctx, stream, consumer)
	ret0, _ := ret[0].(adapter.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Consumer indicates an expected call of Consumer.
func (mr *MockJetStreamMockRecorder) Consumer(ctx, stream, consumer interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consumer", reflect.TypeOf((*MockJetStream)(nil).Consumer), ctx, stream, consumer)
}

// CreateOrUpdateConsumer mocks base method.
func (m *MockJetStream) CreateOrUpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (adapter.Consumer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateOrUpdateConsumer", ctx, stream, cfg)
	ret0, _ := ret[0].(adapter.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateOrUpdateConsumer indicates an expected call of CreateOrUpdateConsumer.
func (mr *MockJetStreamMockRecorder) CreateOrUpdateConsumer(ctx, stream, cfg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateConsumer", reflect.TypeOf((*MockJetStream)(nil).CreateOrUpdateConsumer), ctx, stream, cfg)
}

// Publish mocks base method.
func (m *MockJetStream) Publish(ctx context.Context, subject string, data []byte, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, subject, data}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(*jetstream.PubAck)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Publish indicates an expected call of Publish.
func (mr *MockJetStreamMockRecorder) Publish(ctx, subject, data interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, subject, data}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockJetStream)(nil).Publish), varargs...)
}

// MockConsumer is a mock of Consumer interface.
type MockConsumer struct {
	ctrl     *gomock.Controller
	recorder *MockConsumerMockRecorder
}

// MockConsumerMockRecorder is the mock recorder for MockConsumer.
type MockConsumerMockRecorder struct {
	mock *MockConsumer
}

// NewMockConsumer creates a new mock instance.
func NewMockConsumer(ctrl *gomock.Controller) *MockConsumer {
	mock := &MockConsumer{ctrl: ctrl}
	mock.recorder = &MockConsumerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumer) EXPECT() *MockConsumerMockRecorder {
	return m.recorder
}

// Consume mocks base method.
func (m *MockConsumer) Consume(handler adapter.MessageHandler, opts ...jetstream.PullConsumeOpt) (adapter.ConsumeContext, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{handler}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Consume", varargs...)
	ret0, _ := ret[0].(adapter.ConsumeContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Consume indicates an expected call of Consume.
func (mr *MockConsumerMockRecorder) Consume(handler interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{handler}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockConsumer)(nil).Consume), varargs...)
}

// Info mocks base method.
func (m *MockConsumer) Info(ctx context.Context) (*jetstream.ConsumerInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info", ctx)
	ret0, _ := ret[0].(*jetstream.ConsumerInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Info indicates an expected call of Info.
func (mr *MockConsumerMockRecorder) Info(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockConsumer)(nil).Info), ctx)
}

// MockConsumeContext is a mock of ConsumeContext interface.
type MockConsumeContext struct {
	ctrl     *gomock.Controller
	recorder *MockConsumeContextMockRecorder
}

// MockConsumeContextMockRecorder is the mock recorder for MockConsumeContext.
type MockConsumeContextMockRecorder struct {
	mock *MockConsumeContext
}

// NewMockConsumeContext creates a new mock instance.
func NewMockConsumeContext(ctrl *gomock.Controller) *MockConsumeContext {
	mock := &MockConsumeContext{ctrl: ctrl}
	mock.recorder = &MockConsumeContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumeContext) EXPECT() *MockConsumeContextMockRecorder {
	return m.recorder
}

// Closed mocks base method.
func (m *MockConsumeContext) Closed() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Closed")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// Closed indicates an expected call of Closed.
func (mr *MockConsumeContextMockRecorder) Closed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Closed", reflect.TypeOf((*MockConsumeContext)(nil).Closed))
}

// Drain mocks base method.
func (m *MockConsumeContext) Drain() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Drain")
}

// Drain indicates an expected call of Drain.
func (mr *MockConsumeContextMockRecorder) Drain() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drain", reflect.TypeOf((*MockConsumeContext)(nil).Drain))
}

// Stop mocks base method.
func (m *MockConsumeContext) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockConsumeContextMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockConsumeContext)(nil).Stop))
}

// MockMessage is a mock of Message interface.
type MockMessage struct {
	ctrl     *gomock.Controller
	recorder *MockMessageMockRecorder
}

// MockMessageMockRecorder is the mock recorder for MockMessage.
type MockMessageMockRecorder struct {
	mock *MockMessage
}

// NewMockMessage creates a new mock instance.
func NewMockMessage(ctrl *gomock.Controller) *MockMessage {
	mock := &MockMessage{ctrl: ctrl}
	mock.recorder = &MockMessageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessage) EXPECT() *MockMessageMockRecorder {
	return m.recorder
}

// Ack mocks base method.
func (m *MockMessage) Ack() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ack")
	ret0, _ := ret[0].(error)
	return ret0
}

// Ack indicates an expected call of Ack.
func (mr *MockMessageMockRecorder) Ack() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ack", reflect.TypeOf((*MockMessage)(nil).Ack))
}

// Data mocks base method.
func (m *MockMessage) Data() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Data")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Data indicates an expected call of Data.
func (mr *MockMessageMockRecorder) Data() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Data", reflect.TypeOf((*MockMessage)(nil).Data))
}

// Metadata mocks base method.
func (m *MockMessage) Metadata() (*jetstream.MsgMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Metadata")
	ret0, _ := ret[0].(*jetstream.MsgMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Metadata indicates an expected call of Metadata.
func (mr *MockMessageMockRecorder) Metadata() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Metadata", reflect.TypeOf((*MockMessage)(nil).Metadata))
}

// Nak mocks base method.
func (m *MockMessage) Nak() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Nak")
	ret0, _ := ret[0].(error)
	return ret0
}

// Nak indicates an expected call of Nak.
func (mr *MockMessageMockRecorder) Nak() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nak", reflect.TypeOf((*MockMessage)(nil).Nak))
}

// Term mocks base method.
func (m *MockMessage) Term() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Term")
	ret0, _ := ret[0].(error)
	return ret0
}

// Term indicates an expected call of Term.
func (mr *MockMessageMockRecorder) Term() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Term", reflect.TypeOf((*MockMessage)(nil).Term))
}

// MockNatsJetStream is a mock of NatsJetStream interface.
type MockNatsJetStream struct {
	ctrl     *gomock.Controller
	recorder *MockNatsJetStreamMockRecorder
}

// MockNatsJetStreamMockRecorder is the mock recorder for MockNatsJetStream.
type MockNatsJetStreamMockRecorder struct {
	mock *MockNatsJetStream
}

// NewMockNatsJetStream creates a new mock instance.
func NewMockNatsJetStream(ctrl *gomock.Controller) *MockNatsJetStream {
	mock := &MockNatsJetStream{ctrl: ctrl}
	mock.recorder = &MockNatsJetStreamMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNatsJetStream) EXPECT() *MockNatsJetStreamMockRecorder {
	return m.recorder
}

// Connect mocks base method.
func (m *MockNatsJetStream) Connect(url string, options ...nats.Option) (adapter.NatsConn, adapter.JetStream, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{url}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Connect", varargs...)
	ret0, _ := ret[0].(adapter.NatsConn)
	ret1, _ := ret[1].(adapter.JetStream)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Connect indicates an expected call of Connect.
func (mr *MockNatsJetStreamMockRecorder) Connect(url interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{url}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockNatsJetStream)(nil).Connect), varargs...)
}
