package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/feral-file/ff-indexer-v2/internal/api/shared/constants"
	"github.com/feral-file/ff-indexer-v2/internal/api/shared/dto"
	apierrors "github.com/feral-file/ff-indexer-v2/internal/api/shared/errors"
	"github.com/feral-file/ff-indexer-v2/internal/api/shared/types"
	"github.com/feral-file/ff-indexer-v2/internal/domain"
	internalTypes "github.com/feral-file/ff-indexer-v2/internal/types"
)

// ID is the resolver for the id field.
func (r *changeResolver) ID(ctx context.Context, obj *dto.ChangeResponse) (Uint64, error) {
	return Uint64(obj.ID), nil
}

// SubjectType is the resolver for the subject_type field.
func (r *changeResolver) SubjectType(ctx context.Context, obj *dto.ChangeResponse) (string, error) {
	return string(obj.SubjectType), nil
}

// Meta is the resolver for the meta field.
func (r *changeResolver) Meta(ctx context.Context, obj *dto.ChangeResponse) (JSON, error) {
	if obj.Meta == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.Meta), nil
}

// Subject is the resolver for the subject field.
func (r *changeResolver) Subject(ctx context.Context, obj *dto.ChangeResponse) (JSON, error) {
	if obj.Subject == nil {
		return JSON("null"), nil
	}
	// Subject is already an interface{}, we need to marshal it to JSON
	bytes, err := json.Marshal(obj.Subject)
	if err != nil {
		return JSON("null"), nil
	}
	return JSON(bytes), nil
}

// Offset is the resolver for the offset field.
func (r *changeListResolver) Offset(ctx context.Context, obj *dto.ChangeListResponse) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *changeListResolver) Total(ctx context.Context, obj *dto.ChangeListResponse) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// TokenID is the resolver for the token_id field.
func (r *enrichmentSourceResolver) TokenID(ctx context.Context, obj *dto.EnrichmentSourceResponse) (Uint64, error) {
	return Uint64(obj.TokenID), nil
}

// VendorJSON is the resolver for the vendor_json field.
func (r *enrichmentSourceResolver) VendorJSON(ctx context.Context, obj *dto.EnrichmentSourceResponse) (JSON, error) {
	if obj.VendorJSON == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.VendorJSON), nil
}

// ProviderMetadata is the resolver for the provider_metadata field.
func (r *mediaAssetResolver) ProviderMetadata(ctx context.Context, obj *dto.MediaAssetResponse) (JSON, error) {
	if obj.ProviderMetadata == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.ProviderMetadata), nil
}

// VariantURLs is the resolver for the variant_urls field.
func (r *mediaAssetResolver) VariantURLs(ctx context.Context, obj *dto.MediaAssetResponse) (JSON, error) {
	if obj.VariantURLs == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.VariantURLs), nil
}

// TriggerTokenIndexing is the resolver for the triggerTokenIndexing field.
func (r *mutationResolver) TriggerTokenIndexing(ctx context.Context, tokenCids []string) (*dto.TriggerIndexingResponse, error) {
	// Validate: token CIDs must be provided
	if len(tokenCids) == 0 {
		return nil, apierrors.NewValidationError("token_cids is required")
	}

	// Validate: maximum number of token CIDs allowed
	if len(tokenCids) > constants.MAX_TOKEN_CIDS_PER_REQUEST {
		return nil, apierrors.NewValidationError(fmt.Sprintf("maximum %d token CIDs allowed", constants.MAX_TOKEN_CIDS_PER_REQUEST))
	}

	// Validate: token CIDs must be valid
	tokenCIDs := make([]domain.TokenCID, len(tokenCids))
	for i, cid := range tokenCids {
		tokenCIDs[i] = domain.TokenCID(cid)
		if !tokenCIDs[i].Valid() {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid token CID: %s", cid))
		}
	}

	// Trigger indexing with only token CIDs (no addresses)
	wr, err := r.executor.TriggerTokenIndexing(ctx, tokenCIDs, nil)
	if err != nil {
		return nil, err
	}
	return wr, nil
}

// TriggerOwnerIndexing is the resolver for the triggerOwnerIndexing field.
func (r *mutationResolver) TriggerOwnerIndexing(ctx context.Context, addresses []string) (*dto.TriggerIndexingResponse, error) {
	// Validate: addresses must be provided
	if len(addresses) == 0 {
		return nil, apierrors.NewValidationError("addresses is required")
	}

	// Validate: maximum number of addresses allowed
	if len(addresses) > constants.MAX_ADDRESSES_PER_REQUEST {
		return nil, apierrors.NewValidationError(fmt.Sprintf("maximum %d addresses allowed", constants.MAX_ADDRESSES_PER_REQUEST))
	}

	// Validate: addresses must be valid
	for _, address := range addresses {
		if !internalTypes.IsTezosAddress(address) && !internalTypes.IsEthereumAddress(address) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid address: %s. Must be a valid Tezos or Ethereum address", address))
		}
	}

	// Trigger indexing with only addresses (no token CIDs)
	wr, err := r.executor.TriggerTokenIndexing(ctx, nil, addresses)
	if err != nil {
		return nil, err
	}
	return wr, nil
}

// TriggerMetadataIndexing is the resolver for the triggerMetadataIndexing field.
func (r *mutationResolver) TriggerMetadataIndexing(ctx context.Context, tokenIds []Uint64, tokenCids []string) (*dto.TriggerIndexingResponse, error) {
	// Validate: at least one of token IDs or token CIDs must be provided
	if len(tokenIds) == 0 && len(tokenCids) == 0 {
		return nil, apierrors.NewValidationError("at least one of token_ids or token_cids is required")
	}

	// Convert token IDs from Uint64 to uint64
	var tokenIDsNative []uint64
	if len(tokenIds) > 0 {
		// Validate: maximum number of token IDs allowed
		if len(tokenIds) > constants.MAX_TOKEN_CIDS_PER_REQUEST {
			return nil, apierrors.NewValidationError(fmt.Sprintf("maximum %d token IDs allowed", constants.MAX_TOKEN_CIDS_PER_REQUEST))
		}

		tokenIDsNative = make([]uint64, len(tokenIds))
		for i, id := range tokenIds {
			ti := ToNativeUint64(&id)
			tokenIDsNative[i] = *ti
		}
	}

	// Convert and validate token CIDs
	var tokenCIDs []domain.TokenCID
	if len(tokenCids) > 0 {
		// Validate: maximum number of token CIDs allowed
		if len(tokenCids) > constants.MAX_TOKEN_CIDS_PER_REQUEST {
			return nil, apierrors.NewValidationError(fmt.Sprintf("maximum %d token CIDs allowed", constants.MAX_TOKEN_CIDS_PER_REQUEST))
		}

		tokenCIDs = make([]domain.TokenCID, len(tokenCids))
		for i, cid := range tokenCids {
			tokenCIDs[i] = domain.TokenCID(cid)
			if !tokenCIDs[i].Valid() {
				return nil, apierrors.NewValidationError(fmt.Sprintf("invalid token CID: %s", cid))
			}
		}
	}

	// Trigger metadata indexing
	wr, err := r.executor.TriggerMetadataIndexing(ctx, tokenIDsNative, tokenCIDs)
	if err != nil {
		return nil, err
	}
	return wr, nil
}

// Offset is the resolver for the offset field.
func (r *paginatedOwnersResolver) Offset(ctx context.Context, obj *dto.PaginatedOwners) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *paginatedOwnersResolver) Total(ctx context.Context, obj *dto.PaginatedOwners) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// Offset is the resolver for the offset field.
func (r *paginatedProvenanceEventsResolver) Offset(ctx context.Context, obj *dto.PaginatedProvenanceEvents) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *paginatedProvenanceEventsResolver) Total(ctx context.Context, obj *dto.PaginatedProvenanceEvents) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// ID is the resolver for the id field.
func (r *provenanceEventResolver) ID(ctx context.Context, obj *dto.ProvenanceEventResponse) (Uint64, error) {
	return Uint64(obj.ID), nil
}

// TokenID is the resolver for the token_id field.
func (r *provenanceEventResolver) TokenID(ctx context.Context, obj *dto.ProvenanceEventResponse) (Uint64, error) {
	return Uint64(obj.TokenID), nil
}

// Chain is the resolver for the chain field.
func (r *provenanceEventResolver) Chain(ctx context.Context, obj *dto.ProvenanceEventResponse) (string, error) {
	return string(obj.Chain), nil
}

// EventType is the resolver for the event_type field.
func (r *provenanceEventResolver) EventType(ctx context.Context, obj *dto.ProvenanceEventResponse) (string, error) {
	return string(obj.EventType), nil
}

// BlockNumber is the resolver for the block_number field.
func (r *provenanceEventResolver) BlockNumber(ctx context.Context, obj *dto.ProvenanceEventResponse) (*Uint64, error) {
	if obj.BlockNumber == nil {
		return nil, nil
	}
	num := Uint64(*obj.BlockNumber)
	return &num, nil
}

// Raw is the resolver for the raw field.
func (r *provenanceEventResolver) Raw(ctx context.Context, obj *dto.ProvenanceEventResponse) (JSON, error) {
	if obj.Raw == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.Raw), nil
}

// Token is the resolver for the token field.
func (r *queryResolver) Token(ctx context.Context, cid string, expands []string, ownersLimit *Uint8, ownersOffset *Uint64, provenanceEventsLimit *Uint8, provenanceEventsOffset *Uint64, provenanceEventsOrder *types.Order) (*dto.TokenResponse, error) {
	// Validate token CID
	if !domain.TokenCID(cid).Valid() {
		return nil, apierrors.NewValidationError("Invalid token CID")
	}

	// Convert expansions to domain.Expansion
	expansions := convertExpansionStrings(expands)

	// Validate expansions
	for _, expansion := range expansions {
		if expansion != types.ExpansionOwners &&
			expansion != types.ExpansionProvenanceEvents &&
			expansion != types.ExpansionEnrichmentSource &&
			expansion != types.ExpansionMetadataMediaAsset &&
			expansion != types.ExpansionEnrichmentSourceMediaAsset {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid expansion: %s. Must be a valid expansion", expansion))
		}
	}

	// Validate provenance event order
	if provenanceEventsOrder != nil && !provenanceEventsOrder.Valid() {
		return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid provenance event order: %s. Must be a valid order", *provenanceEventsOrder))
	}

	// Get token
	token, err := r.executor.GetToken(ctx, cid, expansions, ToNativeUint8(ownersLimit), ToNativeUint64(ownersOffset), ToNativeUint8(provenanceEventsLimit), ToNativeUint64(provenanceEventsOffset), provenanceEventsOrder)
	if err != nil {
		return nil, err
	}

	if token == nil {
		return nil, apierrors.NewNotFoundError("Token not found")
	}

	return token, nil
}

// Tokens is the resolver for the tokens field.
func (r *queryResolver) Tokens(ctx context.Context, owners []string, chains []string, contractAddresses []string, tokenNumbers []string, tokenIds []Uint64, tokenCids []string, limit *Uint8, offset *Uint64, expands []string, ownersLimit *Uint8, ownersOffset *Uint64, provenanceEventsLimit *Uint8, provenanceEventsOffset *Uint64, provenanceEventsOrder *types.Order) (*dto.TokenListResponse, error) {
	// Convert query parameters to executor parameters
	expansions := convertExpansionStrings(expands)
	blockchains := convertChainStrings(chains)

	// Validate owners
	for _, o := range owners {
		if !internalTypes.IsTezosAddress(o) && !internalTypes.IsEthereumAddress(o) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid owner: %s. Must be a valid Tezos or Ethereum address", o))
		}
	}

	// Validate chains
	for _, c := range blockchains {
		if !domain.IsValidChain(c) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid chain: %s. Must be a valid Tezos or Ethereum chain", c))
		}
	}

	// Validate contract addresses
	for _, ca := range contractAddresses {
		if !internalTypes.IsTezosContractAddress(ca) && !internalTypes.IsEthereumAddress(ca) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid contract address: %s. Must be a valid Tezos or Ethereum address", ca))
		}
	}

	// Validate token numbers
	for _, t := range tokenNumbers {
		if !internalTypes.IsNumeric(t) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid token number: %s. Must be a valid positive numeric value", t))
		}
	}

	// Validate token CIDs
	for _, t := range tokenCids {
		if !domain.TokenCID(t).Valid() {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid token CID: %s. Must be a valid token CID", t))
		}
	}

	// Validate expansions
	for _, expansion := range expansions {
		if expansion != types.ExpansionOwners &&
			expansion != types.ExpansionProvenanceEvents &&
			expansion != types.ExpansionEnrichmentSource &&
			expansion != types.ExpansionMetadataMediaAsset &&
			expansion != types.ExpansionEnrichmentSourceMediaAsset {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid expansion: %s. Must be a valid expansion", expansion))
		}
	}

	// Validate provenance event order
	if provenanceEventsOrder != nil && !provenanceEventsOrder.Valid() {
		return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid provenance event order: %s. Must be a valid order", *provenanceEventsOrder))
	}

	return r.executor.GetTokens(ctx, owners, blockchains, contractAddresses, tokenNumbers, convertToUint64(tokenIds), tokenCids, ToNativeUint8(limit), ToNativeUint64(offset), expansions, ToNativeUint8(ownersLimit), ToNativeUint64(ownersOffset), ToNativeUint8(provenanceEventsLimit), ToNativeUint64(provenanceEventsOffset), provenanceEventsOrder)
}

// Changes is the resolver for the changes field.
func (r *queryResolver) Changes(ctx context.Context, tokenIds []Uint64, tokenCids []string, addresses []string, subjectTypes []string, subjectIds []string, since *string, limit *Uint8, offset *Uint64, order *types.Order, expand []string) (*dto.ChangeListResponse, error) {
	// Convert query parameters to executor parameters
	expansions := convertExpansionStrings(expand)
	sinceTime, err := parseSinceTimestamp(since)
	if err != nil {
		return nil, fmt.Errorf("invalid since timestamp: %w", err)
	}

	// Validate token CIDs
	for _, tokenCid := range tokenCids {
		if !domain.TokenCID(tokenCid).Valid() {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid token CID: %s. Must be a valid token CID", tokenCid))
		}
	}

	// Validate addresses
	for _, address := range addresses {
		if !internalTypes.IsTezosAddress(address) && !internalTypes.IsEthereumAddress(address) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid address: %s. Must be a valid Tezos or Ethereum address", address))
		}
	}

	// Validate expansions
	for _, expansion := range expansions {
		if expansion != types.ExpansionSubject {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid expansion: %s. Must be a valid expansion", expansion))
		}
	}

	// Validate order
	if order != nil && !order.Valid() {
		return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid order: %s. Must be a valid order", *order))
	}

	return r.executor.GetChanges(ctx, convertToUint64(tokenIds), tokenCids, addresses, convertSubjectTypes(subjectTypes), subjectIds, sinceTime, ToNativeUint8(limit), ToNativeUint64(offset), order, expansions)
}

// WorkflowStatus is the resolver for the workflowStatus field.
func (r *queryResolver) WorkflowStatus(ctx context.Context, workflowID string, runID string) (*dto.WorkflowStatusResponse, error) {
	return r.executor.GetWorkflowStatus(ctx, workflowID, runID)
}

// ID is the resolver for the id field.
func (r *tokenResolver) ID(ctx context.Context, obj *dto.TokenResponse) (Uint64, error) {
	return Uint64(obj.ID), nil
}

// Chain is the resolver for the chain field.
func (r *tokenResolver) Chain(ctx context.Context, obj *dto.TokenResponse) (string, error) {
	return string(obj.Chain), nil
}

// Standard is the resolver for the standard field.
func (r *tokenResolver) Standard(ctx context.Context, obj *dto.TokenResponse) (string, error) {
	return string(obj.Standard), nil
}

// Offset is the resolver for the offset field.
func (r *tokenListResolver) Offset(ctx context.Context, obj *dto.TokenListResponse) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *tokenListResolver) Total(ctx context.Context, obj *dto.TokenListResponse) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// TokenID is the resolver for the token_id field.
func (r *tokenMetadataResolver) TokenID(ctx context.Context, obj *dto.TokenMetadataResponse) (Uint64, error) {
	return Uint64(obj.TokenID), nil
}

// OriginJSON is the resolver for the origin_json field.
func (r *tokenMetadataResolver) OriginJSON(ctx context.Context, obj *dto.TokenMetadataResponse) (JSON, error) {
	if obj.OriginJSON == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.OriginJSON), nil
}

// LatestJSON is the resolver for the latest_json field.
func (r *tokenMetadataResolver) LatestJSON(ctx context.Context, obj *dto.TokenMetadataResponse) (JSON, error) {
	if obj.LatestJSON == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.LatestJSON), nil
}

// ExecutionTime is the resolver for the execution_time_ms field.
func (r *workflowStatusResolver) ExecutionTime(ctx context.Context, obj *dto.WorkflowStatusResponse) (*Uint64, error) {
	if obj.ExecutionTime == nil {
		return nil, nil
	}
	val := Uint64(*obj.ExecutionTime)
	return &val, nil
}

// Change returns ChangeResolver implementation.
func (r *Resolver) Change() ChangeResolver { return &changeResolver{r} }

// ChangeList returns ChangeListResolver implementation.
func (r *Resolver) ChangeList() ChangeListResolver { return &changeListResolver{r} }

// EnrichmentSource returns EnrichmentSourceResolver implementation.
func (r *Resolver) EnrichmentSource() EnrichmentSourceResolver { return &enrichmentSourceResolver{r} }

// MediaAsset returns MediaAssetResolver implementation.
func (r *Resolver) MediaAsset() MediaAssetResolver { return &mediaAssetResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// PaginatedOwners returns PaginatedOwnersResolver implementation.
func (r *Resolver) PaginatedOwners() PaginatedOwnersResolver { return &paginatedOwnersResolver{r} }

// PaginatedProvenanceEvents returns PaginatedProvenanceEventsResolver implementation.
func (r *Resolver) PaginatedProvenanceEvents() PaginatedProvenanceEventsResolver {
	return &paginatedProvenanceEventsResolver{r}
}

// ProvenanceEvent returns ProvenanceEventResolver implementation.
func (r *Resolver) ProvenanceEvent() ProvenanceEventResolver { return &provenanceEventResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Token returns TokenResolver implementation.
func (r *Resolver) Token() TokenResolver { return &tokenResolver{r} }

// TokenList returns TokenListResolver implementation.
func (r *Resolver) TokenList() TokenListResolver { return &tokenListResolver{r} }

// TokenMetadata returns TokenMetadataResolver implementation.
func (r *Resolver) TokenMetadata() TokenMetadataResolver { return &tokenMetadataResolver{r} }

// WorkflowStatus returns WorkflowStatusResolver implementation.
func (r *Resolver) WorkflowStatus() WorkflowStatusResolver { return &workflowStatusResolver{r} }

type changeResolver struct{ *Resolver }
type changeListResolver struct{ *Resolver }
type enrichmentSourceResolver struct{ *Resolver }
type mediaAssetResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type paginatedOwnersResolver struct{ *Resolver }
type paginatedProvenanceEventsResolver struct{ *Resolver }
type provenanceEventResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tokenResolver struct{ *Resolver }
type tokenListResolver struct{ *Resolver }
type tokenMetadataResolver struct{ *Resolver }
type workflowStatusResolver struct{ *Resolver }
