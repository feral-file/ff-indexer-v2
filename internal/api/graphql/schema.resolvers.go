package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/feral-file/ff-indexer-v2/internal/api/shared/constants"
	"github.com/feral-file/ff-indexer-v2/internal/api/shared/dto"
	apierrors "github.com/feral-file/ff-indexer-v2/internal/api/shared/errors"
	"github.com/feral-file/ff-indexer-v2/internal/api/shared/types"
	"github.com/feral-file/ff-indexer-v2/internal/domain"
	internalTypes "github.com/feral-file/ff-indexer-v2/internal/types"
)

// ID is the resolver for the id field.
func (r *changeResolver) ID(ctx context.Context, obj *dto.ChangeResponse) (Uint64, error) {
	return Uint64(obj.ID), nil
}

// SubjectType is the resolver for the subject_type field.
func (r *changeResolver) SubjectType(ctx context.Context, obj *dto.ChangeResponse) (string, error) {
	return string(obj.SubjectType), nil
}

// Meta is the resolver for the meta field.
func (r *changeResolver) Meta(ctx context.Context, obj *dto.ChangeResponse) (JSON, error) {
	if obj.Meta == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.Meta), nil
}

// Subject is the resolver for the subject field.
func (r *changeResolver) Subject(ctx context.Context, obj *dto.ChangeResponse) (JSON, error) {
	if obj.Subject == nil {
		return JSON("null"), nil
	}
	// Subject is already an interface{}, we need to marshal it to JSON
	bytes, err := json.Marshal(obj.Subject)
	if err != nil {
		return JSON("null"), nil
	}
	return JSON(bytes), nil
}

// Offset is the resolver for the offset field.
func (r *changeListResolver) Offset(ctx context.Context, obj *dto.ChangeListResponse) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *changeListResolver) Total(ctx context.Context, obj *dto.ChangeListResponse) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// TokenID is the resolver for the token_id field.
func (r *enrichmentSourceResolver) TokenID(ctx context.Context, obj *dto.EnrichmentSourceResponse) (Uint64, error) {
	return Uint64(obj.TokenID), nil
}

// VendorJSON is the resolver for the vendor_json field.
func (r *enrichmentSourceResolver) VendorJSON(ctx context.Context, obj *dto.EnrichmentSourceResponse) (JSON, error) {
	if obj.VendorJSON == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.VendorJSON), nil
}

// ProviderMetadata is the resolver for the provider_metadata field.
func (r *mediaAssetResolver) ProviderMetadata(ctx context.Context, obj *dto.MediaAssetResponse) (JSON, error) {
	if obj.ProviderMetadata == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.ProviderMetadata), nil
}

// VariantURLs is the resolver for the variant_urls field.
func (r *mediaAssetResolver) VariantURLs(ctx context.Context, obj *dto.MediaAssetResponse) (JSON, error) {
	if obj.VariantURLs == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.VariantURLs), nil
}

// TriggerIndexing is the resolver for the triggerIndexing field.
func (r *mutationResolver) TriggerIndexing(ctx context.Context, tokenCids []string, addresses []string) (*dto.TriggerIndexingResponse, error) {
	hasTokenCIDs := len(tokenCids) > 0
	hasAddresses := len(addresses) > 0

	// Validate: only one type of input should be provided
	if hasTokenCIDs && hasAddresses {
		return nil, apierrors.NewValidationError("cannot provide both token_cids and addresses")
	}

	// Validate: maximum number of token CIDs allowed
	if hasTokenCIDs && len(tokenCids) > constants.MAX_TOKEN_CIDS_PER_REQUEST {
		return nil, apierrors.NewValidationError(fmt.Sprintf("maximum %d token CIDs allowed", constants.MAX_TOKEN_CIDS_PER_REQUEST))
	}

	// Validate: maximum number of addresses allowed
	if hasAddresses && len(addresses) > constants.MAX_ADDRESSES_PER_REQUEST {
		return nil, apierrors.NewValidationError(fmt.Sprintf("maximum %d addresses allowed", constants.MAX_ADDRESSES_PER_REQUEST))
	}

	// Validate: addresses must be valid
	for _, address := range addresses {
		if !internalTypes.IsTezosAddress(address) && !internalTypes.IsEthereumAddress(address) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid address: %s. Must be a valid Tezos or Ethereum address", address))
		}
	}

	// Validate: token CIDs must be valid
	tokenCIDs := make([]domain.TokenCID, len(tokenCids))
	for i, cid := range tokenCids {
		tokenCIDs[i] = domain.TokenCID(cid)
		if !tokenCIDs[i].Valid() {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid token CID: %s", cid))
		}
	}

	// Trigger indexing
	wr, err := r.executor.TriggerTokenIndexing(ctx, tokenCIDs, addresses)
	if err != nil {
		return nil, err
	}
	return wr, nil
}

// Offset is the resolver for the offset field.
func (r *paginatedOwnersResolver) Offset(ctx context.Context, obj *dto.PaginatedOwners) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *paginatedOwnersResolver) Total(ctx context.Context, obj *dto.PaginatedOwners) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// Offset is the resolver for the offset field.
func (r *paginatedProvenanceEventsResolver) Offset(ctx context.Context, obj *dto.PaginatedProvenanceEvents) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *paginatedProvenanceEventsResolver) Total(ctx context.Context, obj *dto.PaginatedProvenanceEvents) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// ID is the resolver for the id field.
func (r *provenanceEventResolver) ID(ctx context.Context, obj *dto.ProvenanceEventResponse) (Uint64, error) {
	return Uint64(obj.ID), nil
}

// TokenID is the resolver for the token_id field.
func (r *provenanceEventResolver) TokenID(ctx context.Context, obj *dto.ProvenanceEventResponse) (Uint64, error) {
	return Uint64(obj.TokenID), nil
}

// Chain is the resolver for the chain field.
func (r *provenanceEventResolver) Chain(ctx context.Context, obj *dto.ProvenanceEventResponse) (string, error) {
	return string(obj.Chain), nil
}

// EventType is the resolver for the event_type field.
func (r *provenanceEventResolver) EventType(ctx context.Context, obj *dto.ProvenanceEventResponse) (string, error) {
	return string(obj.EventType), nil
}

// BlockNumber is the resolver for the block_number field.
func (r *provenanceEventResolver) BlockNumber(ctx context.Context, obj *dto.ProvenanceEventResponse) (*Uint64, error) {
	if obj.BlockNumber == nil {
		return nil, nil
	}
	num := Uint64(*obj.BlockNumber)
	return &num, nil
}

// Raw is the resolver for the raw field.
func (r *provenanceEventResolver) Raw(ctx context.Context, obj *dto.ProvenanceEventResponse) (JSON, error) {
	if obj.Raw == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.Raw), nil
}

// Token is the resolver for the token field.
func (r *queryResolver) Token(ctx context.Context, cid string, expand []string, ownersLimit *Uint8, ownersOffset *Uint64, provenanceEventsLimit *Uint8, provenanceEventsOffset *Uint64, provenanceEventsOrder *types.Order) (*dto.TokenResponse, error) {
	// Validate token CID
	if !domain.TokenCID(cid).Valid() {
		return nil, apierrors.NewValidationError("Invalid token CID")
	}

	// Convert expansions to domain.Expansion
	expansions := convertExpansionStrings(expand)

	// Validate expansions
	for _, expansion := range expansions {
		if expansion != types.ExpansionOwners &&
			expansion != types.ExpansionProvenanceEvents &&
			expansion != types.ExpansionEnrichmentSource &&
			expansion != types.ExpansionMetadataMediaAsset &&
			expansion != types.ExpansionEnrichmentSourceMediaAsset {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid expansion: %s. Must be a valid expansion", expansion))
		}
	}

	// Validate provenance event order
	if provenanceEventsOrder != nil && !provenanceEventsOrder.Valid() {
		return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid provenance event order: %s. Must be a valid order", *provenanceEventsOrder))
	}

	// Get token
	token, err := r.executor.GetToken(ctx, cid, expansions, ToNativeUint8(ownersLimit), ToNativeUint64(ownersOffset), ToNativeUint8(provenanceEventsLimit), ToNativeUint64(provenanceEventsOffset), provenanceEventsOrder)
	if err != nil {
		return nil, err
	}

	if token == nil {
		return nil, apierrors.NewNotFoundError("Token not found")
	}

	return token, nil
}

// Tokens is the resolver for the tokens field.
func (r *queryResolver) Tokens(ctx context.Context, owner []string, chain []string, contractAddress []string, tokenID []string, limit *Uint8, offset *Uint64, expand []string, ownersLimit *Uint8, ownersOffset *Uint64, provenanceEventsLimit *Uint8, provenanceEventsOffset *Uint64, provenanceEventsOrder *types.Order) (*dto.TokenListResponse, error) {
	// Convert query parameters to executor parameters
	expansions := convertExpansionStrings(expand)
	chains := convertChainStrings(chain)

	// Validate owners
	for _, owner := range owner {
		if !internalTypes.IsTezosAddress(owner) && !internalTypes.IsEthereumAddress(owner) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid owner: %s. Must be a valid Tezos or Ethereum address", owner))
		}
	}

	// Validate chains
	for _, chain := range chains {
		if !domain.IsValidChain(chain) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid chain: %s. Must be a valid Tezos or Ethereum chain", chain))
		}
	}

	// Validate contract addresses
	for _, contractAddress := range contractAddress {
		if !internalTypes.IsTezosContractAddress(contractAddress) && !internalTypes.IsEthereumAddress(contractAddress) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid contract address: %s. Must be a valid Tezos or Ethereum address", contractAddress))
		}
	}

	// Validate token IDs
	for _, tokenID := range tokenID {
		if !internalTypes.IsNumeric(tokenID) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("invalid token ID: %s. Must be a valid positive numeric value", tokenID))
		}
	}

	// Validate expansions
	for _, expansion := range expansions {
		if expansion != types.ExpansionOwners &&
			expansion != types.ExpansionProvenanceEvents &&
			expansion != types.ExpansionEnrichmentSource &&
			expansion != types.ExpansionMetadataMediaAsset &&
			expansion != types.ExpansionEnrichmentSourceMediaAsset {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid expansion: %s. Must be a valid expansion", expansion))
		}
	}

	// Validate provenance event order
	if provenanceEventsOrder != nil && !provenanceEventsOrder.Valid() {
		return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid provenance event order: %s. Must be a valid order", *provenanceEventsOrder))
	}

	return r.executor.GetTokens(ctx, owner, chains, contractAddress, tokenID, ToNativeUint8(limit), ToNativeUint64(offset), expansions, ToNativeUint8(ownersLimit), ToNativeUint64(ownersOffset), ToNativeUint8(provenanceEventsLimit), ToNativeUint64(provenanceEventsOffset), provenanceEventsOrder)
}

// Changes is the resolver for the changes field.
func (r *queryResolver) Changes(ctx context.Context, tokenCid []string, address []string, since *string, limit *Uint8, offset *Uint64, order *types.Order, expand []string) (*dto.ChangeListResponse, error) {
	// Convert query parameters to executor parameters
	expansions := convertExpansionStrings(expand)
	sinceTime, err := parseSinceTimestamp(since)
	if err != nil {
		return nil, fmt.Errorf("invalid since timestamp: %w", err)
	}

	// Validate token CIDs
	for _, tokenCid := range tokenCid {
		if !domain.TokenCID(tokenCid).Valid() {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid token CID: %s. Must be a valid token CID", tokenCid))
		}
	}

	// Validate addresses
	for _, address := range address {
		if !internalTypes.IsTezosAddress(address) && !internalTypes.IsEthereumAddress(address) {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid address: %s. Must be a valid Tezos or Ethereum address", address))
		}
	}

	// Validate expansions
	for _, expansion := range expansions {
		if expansion != types.ExpansionSubject {
			return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid expansion: %s. Must be a valid expansion", expansion))
		}
	}

	// Validate order
	if order != nil && !order.Valid() {
		return nil, apierrors.NewValidationError(fmt.Sprintf("Invalid order: %s. Must be a valid order", *order))
	}

	return r.executor.GetChanges(ctx, tokenCid, address, sinceTime, ToNativeUint8(limit), ToNativeUint64(offset), order, expansions)
}

// ID is the resolver for the id field.
func (r *tokenResolver) ID(ctx context.Context, obj *dto.TokenResponse) (Uint64, error) {
	return Uint64(obj.ID), nil
}

// Chain is the resolver for the chain field.
func (r *tokenResolver) Chain(ctx context.Context, obj *dto.TokenResponse) (string, error) {
	return string(obj.Chain), nil
}

// Standard is the resolver for the standard field.
func (r *tokenResolver) Standard(ctx context.Context, obj *dto.TokenResponse) (string, error) {
	return string(obj.Standard), nil
}

// Offset is the resolver for the offset field.
func (r *tokenListResolver) Offset(ctx context.Context, obj *dto.TokenListResponse) (*Uint64, error) {
	return FromNativeUint64(obj.Offset), nil
}

// Total is the resolver for the total field.
func (r *tokenListResolver) Total(ctx context.Context, obj *dto.TokenListResponse) (Uint64, error) {
	return Uint64(obj.Total), nil
}

// TokenID is the resolver for the token_id field.
func (r *tokenMetadataResolver) TokenID(ctx context.Context, obj *dto.TokenMetadataResponse) (Uint64, error) {
	return Uint64(obj.TokenID), nil
}

// OriginJSON is the resolver for the origin_json field.
func (r *tokenMetadataResolver) OriginJSON(ctx context.Context, obj *dto.TokenMetadataResponse) (JSON, error) {
	if obj.OriginJSON == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.OriginJSON), nil
}

// LatestJSON is the resolver for the latest_json field.
func (r *tokenMetadataResolver) LatestJSON(ctx context.Context, obj *dto.TokenMetadataResponse) (JSON, error) {
	if obj.LatestJSON == nil {
		return JSON("{}"), nil
	}
	return JSON(obj.LatestJSON), nil
}

// Change returns ChangeResolver implementation.
func (r *Resolver) Change() ChangeResolver { return &changeResolver{r} }

// ChangeList returns ChangeListResolver implementation.
func (r *Resolver) ChangeList() ChangeListResolver { return &changeListResolver{r} }

// EnrichmentSource returns EnrichmentSourceResolver implementation.
func (r *Resolver) EnrichmentSource() EnrichmentSourceResolver { return &enrichmentSourceResolver{r} }

// MediaAsset returns MediaAssetResolver implementation.
func (r *Resolver) MediaAsset() MediaAssetResolver { return &mediaAssetResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// PaginatedOwners returns PaginatedOwnersResolver implementation.
func (r *Resolver) PaginatedOwners() PaginatedOwnersResolver { return &paginatedOwnersResolver{r} }

// PaginatedProvenanceEvents returns PaginatedProvenanceEventsResolver implementation.
func (r *Resolver) PaginatedProvenanceEvents() PaginatedProvenanceEventsResolver {
	return &paginatedProvenanceEventsResolver{r}
}

// ProvenanceEvent returns ProvenanceEventResolver implementation.
func (r *Resolver) ProvenanceEvent() ProvenanceEventResolver { return &provenanceEventResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Token returns TokenResolver implementation.
func (r *Resolver) Token() TokenResolver { return &tokenResolver{r} }

// TokenList returns TokenListResolver implementation.
func (r *Resolver) TokenList() TokenListResolver { return &tokenListResolver{r} }

// TokenMetadata returns TokenMetadataResolver implementation.
func (r *Resolver) TokenMetadata() TokenMetadataResolver { return &tokenMetadataResolver{r} }

type changeResolver struct{ *Resolver }
type changeListResolver struct{ *Resolver }
type enrichmentSourceResolver struct{ *Resolver }
type mediaAssetResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type paginatedOwnersResolver struct{ *Resolver }
type paginatedProvenanceEventsResolver struct{ *Resolver }
type provenanceEventResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type tokenResolver struct{ *Resolver }
type tokenListResolver struct{ *Resolver }
type tokenMetadataResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *tokenMetadataResolver) CreatedAt(ctx context.Context, obj *dto.TokenMetadataResponse) (*time.Time, error) {
	return &obj.CreatedAt, nil
}
func (r *tokenMetadataResolver) UpdatedAt(ctx context.Context, obj *dto.TokenMetadataResponse) (*time.Time, error) {
	return &obj.UpdatedAt, nil
}
*/
